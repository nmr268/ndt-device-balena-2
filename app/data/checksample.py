#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Run the complete process of checking a sample.

Running this without any arguments will run silently.
Internally stdout and stderr are redirected to a log file.
When ready to start capturing it will wait until receiving a SIGUSR1 signal.
Any exceptions raised is catched and the output written to stderr which is
redirected to the log. This log and other data will be packed up and stored in
the debug dir with a timestamp as part of the name.
It will return a 0 (zero) on success.

You can give a single argument: terminal
This will make the program drop the stdout and stderr redirection and you
will therefore get an output on the terminal instead of in the log.
It will also ask you to press enter instead of waiting for SIGUSR1.

"""

__copyright__ = "Copyright (C) 2020 Nordetect"

import analyseconfig

import signal
from os import path, remove as removefile
import filelog

if __name__ == '__main__':
    from sys import argv
    if len(argv) == 2 and argv[1] == "daemon":
        run_as_daemon = True
    else:
        run_as_daemon = False
        # First we want to block the signals we want to wait for so we don't
        # risk the standard handler taking them.
        signal.pthread_sigmask(signal.SIG_BLOCK, [signal.SIGUSR1])

    # We can not import sys (stdout and stderr) before we have set up the
    # logging and we want to do as much as possible after this point to get
    # errors into our debug log.
    using_controller = True
    if len(argv) == 2 and argv[1] == "terminal":
        using_controller = False
    if using_controller:
        # As we now run as a daemon, deleting the log between sample checks
        # will stop any further output to the log, so instead make it a more
        # permanent log only deleted here or at system restart.
        try:
            removefile(path.join(analyseconfig.tmp_dir, analyseconfig.checksample_log_name))
        except FileNotFoundError:
            pass
        filelog.setup_file_log(analyseconfig.tmp_dir, analyseconfig.checksample_log_name)
        print("")
        print("================================================================================")
    print("Starting checksample.py")
    print("")

from cameracontrol import Camera
from colortable import colortable
if __name__ == '__main__':
    # The camera takes time to be ready, so lets start the process early
    # before using time on our imports
    print("Preparing Camera")
    camera = Camera()
    if not run_as_daemon:
        # Light also takes a little time, so also prepare that
        print("Preparing Light")
        firsttime = 100000
        color = 'off'
        for spotindex, active in enumerate(analyseconfig.spot_active):
            if active and analyseconfig.spot_timing[spotindex] < firsttime:
                firsttime = analyseconfig.spot_timing[spotindex]
                color = analyseconfig.spot_light_color[spotindex]
        # Only turn the light on if we will not have enough time later
        if firsttime + analyseconfig.average_times[0] < camera.light_settle_time:
            camera.setlight(colortable[color])

import sys
from os import makedirs, getpid
from time import clock_gettime, CLOCK_MONOTONIC
from typing import List, Tuple

from utils import *
from checksample_com import Status,  store_daemon_pid
import predictNewSample


CaptureInfo = Tuple[int, str, str]


class CheckSampleException(Exception):

    """Base class for all exceptions generated by checksample code."""

    pass


class AbortCheckException(CheckSampleException):

    """Exception for aborting the current check."""

    def __init__(self) -> None:
        """Standard init function just calling the parent with a desciption."""
        super().__init__(self, "Request for aborting current check.")


def capture(camera: Camera, dirname: str, filename: str) -> None:
    """Capture the image needed to analyse a sample.

    This should be changed according to the capture needs.
    Maybe to capture multible images.

    Parameters:
        dirname: Directory to store the captured images.
        filename: Filename of the captured image.

    """
    camera.setlight(colortable['red'])
    camera.capture_image()
    camera.save_image(path.join(dirname, filename))
    camera.setlight(colortable['off'])


def capture_all(camera: Camera, basedirname: str, filename: str, starttime: float) -> List[CaptureInfo]:
    """Capture all needed images for full analysis.

    Parameters:
        camera: The Camera object to use for capture.
        basedirname: The work dir to put things in.
        filename: Name of image files.
        starttime: The starttime for capture time calculations.
    Returns:
        List of (spot number, image dir, image file).

    """
    worklist = []
    for spotindex, active in enumerate(analyseconfig.spot_active):
        if active:
            worklist.append((analyseconfig.spot_timing[spotindex], spotindex))
    worklist.sort()
    capturelist = []
    for capturetime, spotindex in worklist:
        camera.setlight(colortable[analyseconfig.spot_light_color[spotindex]])
        camera.capture_average([x + capturetime for x in analyseconfig.average_times], starttime)
        camera.setlight(colortable['off'])
        dirname = path.join(basedirname, analyseconfig.spot_model_names[spotindex])
        makedirs(path.abspath(dirname), exist_ok=True)
        camera.save_image(path.join(dirname, filename))
        spot = spotindex + 1
        capturelist.append((spot, dirname, filename))
    return capturelist


def analyse_all(capturelist: List[CaptureInfo]) -> Results:
    """Analyse all the spots we are looking at.

    Parameters:
        capturelist: A list of (spot number, image dir, image file)
    Returns:
        Results of the analysis.

    """
    results = create_default_results()
    for spot, dirname, filename in capturelist:
        predictNewSample.predict_sample(dirname, filename, [spot], results)
    return results


def check_sample(camera: Camera, starttime: float, resultdir: str = analyseconfig.results_dir) -> None:
    """Do the full chain to check a sample.

    This will do all the work needed to check a sample:
    Capture, pre processing, analysis, post processing.

    Parameters:
        resultdir: The directory where work files and results should be placed.

    """
    makedirs(path.abspath(resultdir), exist_ok=True)
    # Capture images of the sample
    print("Capturing")
    capturelist = capture_all(camera, resultdir, analyseconfig.sample_filename, starttime)
    # Do the prediction
    results = analyse_all(capturelist)
    save_results(resultdir, analyseconfig.results_filename, results)


def single_check() -> None:
    """Check a single sample."""
    try:
        log(logfile, "Single run checksample started")
        prepare_for_check_sample()
        print("Waiting for the camera and light to be ready.")
        camera.wait_for_ready(wait_for_light=False)
        Status.set_status(Status.READY)
        # Wait for signal to indicate start
        if using_controller:
            print("Waiting for SIGUSR1 signal.")
            signal.sigwait([signal.SIGUSR1])
        else:
            input("Press enter to start the capture and analysis process")
        log(logfile, "Starting to check a sample.")
        starttime = clock_gettime(CLOCK_MONOTONIC)
        check_sample(camera, starttime)
    except Exception as e:
        collect_debuginfo(e)
        make_error_results_file()
        Status.set_status(Status.ERROR)
        sys.exit(1)
    else:
        Status.set_status(Status.DONE)
        log(logfile, "We successfully checked a sample.")


class Daemon():

    """Class for running check sample as a daemon."""

    def __init__(self) -> None:
        """Constructor."""
        self.running_daemon = False
        self.running_check = False
        self.aborting = False
        signal.signal(signal.SIGUSR1, lambda signal, frame: self.handler_usr1())
        signal.signal(signal.SIGTERM, lambda signal, frame: self.handler_exit())
        signal.signal(signal.SIGHUP, lambda signal, frame: self.handler_abort())

    def handler_usr1(self) -> None:
        """Handler for SIGUSR1 indicating we want to start a sample check."""
        # Only run if we are not already running a check
        if not self.running_check:
            try:
                self.running_check = True
                if self.aborting:
                    return
                starttime = clock_gettime(CLOCK_MONOTONIC)
                Status.set_status(Status.RUNNING)
                prepare_for_check_sample()
                log(logfile, "Starting to check a sample.")
                check_sample(camera, starttime)
            except AbortCheckException:
                # We got a request to abort, so not an error, just get out.
                log(logfile, "Request for abort was made before we finished.")
            except Exception as e:
                collect_debuginfo(e)
                make_error_results_file()
            else:
                log(logfile, "We successfully checked a sample.")
            finally:
                # Always make sure the light is turned off
                camera.setlight(colortable['off'])
                self.running_check = False

    def handler_abort(self) -> None:
        """Handler for aborting current check."""
        print('Aborting')
        self.aborting = True
        if self.running_check:
            raise AbortCheckException()

    def handler_exit(self) -> None:
        """Handler for exit signals."""
        print('Exiting')
        self.running_daemon = False
        self.handler_abort()

    def run(self) -> None:
        """Run the daemon loop."""
        log(logfile, "Check sample daemon started")
        self.running_daemon = True
        camera.wait_for_ready(wait_for_light=False)
        while self.running_daemon:
            Status.set_status(Status.READY)
            signal.pause()
            self.aborting = False
        Status.set_status(Status.UNAVAILABLE)
        log(logfile, "Check sample daemon exiting")


if __name__ == '__main__':
    store_daemon_pid(getpid())
    Status.setup()
    Status.set_status(Status.UNAVAILABLE)
    # Make sure we have a dir to put our general logs in
    makedirs(path.abspath(analyseconfig.log_dir), exist_ok=True)
    # Set up some static variables
    results_file = path.join(analyseconfig.results_dir, analyseconfig.results_filename)
    logfile = path.join(analyseconfig.log_dir, analyseconfig.log_name)
    log(logfile, "")
    log(logfile, "================================================================================")
    if run_as_daemon:
        daemon = Daemon()
        daemon.run()
    else:
        single_check()
